# Cordic Rotate

cordic算法是用来做向量的角度旋转的算法，角度的旋转就涉及道进行对角度的正弦余弦变化， 如果直接对角度进行正弦余弦变化要么使用DSP实现，要么通过大容量的ROM来预存计算结果。 这是不好的，所以一般我们会通过cordic算法，进行简单结构的迭代，来实现cordic

## Cordic Rotate Algorithm
<img src="H:/Personal Study/Cordic/Cordic Rotate Algorithm.png" height="400" width = "500" />  

1. 三角恒等式：  
<img src = "H:/Personal Study/Cordic/cos.png" />  

通过上面个两幅图，知道只需要通过对公式的迭代就能不断逼近预旋转的角度。这里每次旋转的角  
度采用tan(a) = 2^-i为基础进行旋转，原因在于这种方式对于坐标进行移位比较方便。在角度旋  
转的时候可以人为设定一个阈值，当两个当前角度和预期实现角度之差小于这个阈值时人为旋转  
完成。

## 实现方式：
<img src="H:/Personal Study/Cordic/cordic rotate implementation.png" height = "300" width = "600" />  
迭代原理如上图所示，按照如图所示的方式进行角度迭代，根据迭代的次数i去访问ROM获取角度的值 (以二进制的方式按比例保存)，角度计算完成之后对坐标进行缩放，缩放因子根据经验公式为：
<img src="H:/Personal Study/Cordic/gain.png" height="150" width="450"/>

## 数据格式：
上述算法的硬件实现不需要通过硬件实现，尽管最后的缩放因子是小数，只需要将其看成整数，最 
调整小数点的位置即可。 角度的存储使用带符号位的定点数，总共24bit，整数部分7bit，小数部分 15bit。数据格式如下：siiiiii.fffffffffffffff;

## Data:
1. **Angles**

| i | 2^-i | theta | 定点数实现 | 定点数的二进制表示 | 
| :------ | :------- | :------- | :------- | :------------------------ |
| 0  |  1           | 45          | 45          | 00101101.00000000000000000 |
| 1  |  0.5         | 26.56505118 | 26.565048   | 00011010.10010000101001110 | 
| 2  |  0.25        | 14.03624347 | 14.036239   | 00001110.00001001010001110 | 
| 3  |  0.125       | 7.125016349 | 7.1250152   | 00000111.00100000000000010 | 
| 4  |  0.0625      | 3.576334375 | 3.57633209  | 00000011.10010011100010101 |
| 5  |  0.03125     | 1.789910608 | 1.789909    | 00000001.11001010001101111 |
| 6  |  0.015625    | 0.89517371  | 0.895172119 | 00000000.11100101001010100 |
| 7  |  0.0078125   | 0.447614171 | 0.4476089   | 00000000.01110010100101101 |
| 8  |  0.00390625  | 0.2238105   | 0.223808    | 00000000.00111001010010111 | 
| 9  |  0.001953125 | 0.111905677 | 0.1119      | 00000000.00011100101001011 | 
| 10 |  0.000976563 | 0.055952892 | 0.055946    | 00000000.00001110010100101 |
| 11 |  0.000488281 | 0.027976453 | 0.02796936  | 00000000.00000111001010010 |
| 12 |  0.000244141 | 0.013988227 | 0.01398468  | 00000000.00000011100101001 |
| 13 |  0.00012207  | 0.006994114 | 0.006988525 | 00000000.00000001110010100 |
| 14 |  6.10352E-05 | 0.003497057 | 0.00349426  | 00000000.00000000111001010 |
| 15 |  3.05176E-05 | 0.001748528 | 0.001747131 | 00000000.00000000011100101 |
| 16 |  1.52588E-05 | 0.000874264 | 0.00086975  | 00000000.00000000001110010 |
| 17 |  7.62939E-06 | 0.000437132 | 0.000434875 | 00000000.00000000000111001 |
| 18 |  3.8147E-06  | 0.000218566 | 0.00021362  | 00000000.00000000000011100 |
| 19 |  1.90735E-06 | 0.000109283 | 0.0001068   | 00000000.00000000000001110 |

2. **k_factor**:

    k_factor = 0.6037 二进制表示为0b0.10011010100011000

## FPGA实现
1. 通过一个坐标变换单元，通过多周期迭代的方式实现。对于坐标x和y的移位由于需要多周期迭代， 
移位的边界是一个变换的值，所以无法通过">> n"实现，只能通过MUX实现，并且需要考虑符号位。
2. 如何判断是否达到了预计的角度旋转，通过设置一个误差阈值，当旋转得到的角度和设计需要的 角度之间的误差小于某个误差阈值ERROR时，认为卷度旋转已经实现，这时终止状态机，并且输出 旋转后的向量坐标和向量角度。
3. 表中的角度都预先存放在了ROM中，但是ROM的访问有一个时钟周期的延迟，所以需要注意计算 时使用的值，是否是需要的值。
4. 有符号数的乘法，一个22bit*21bit的有符号数相乘，得到的结果是43bit的有符号数(最高位为符号位， 剩余部分为数值位)，由于是定点数格式，所以进行截位量化，取最高21bit数作为最终输出结果。
5. 关键问题在于cordic\_start, cordic\_finish, cordic_active三个状态控制信号下的状态转换和对应的计算 关系。尤其是当iter\_cnt超过ROM的访问地址之后的处理。
    1. 理想情况下cordic\_active是在检测到cordic\_finish之后立即拉低。而cordic\_finishi在超过迭代次数 或者在没有超过迭代次数的情况下角度误差达到目标阈值的情况下有效。当finish信号拉高之后如 果没有start则会一直为高
    2. cordic\_acitve在检测到cordic\_start信号之后立即拉高
    3. 理想波形如下所示：
    <img src="H:/Personal Study/Cordic/ideal_waveform.png" height = "250" width = "900" />  